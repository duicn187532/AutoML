/* ========= ÂÖ®ÂüüÁãÄÊÖã ========= */
let rawData = [], columns = [];
let meta = null;                // ÂâçËôïÁêÜËàá‰ªªÂãôË≥áË®ä
let tfModel = null;             // TF.js Ê®°ÂûãÔºàÊàñ nullÔºâ
let traditionalModel = null;    // MLBundle ÂÇ≥Áµ±Ê®°ÂûãÔºàÊàñ nullÔºâ
let lastPredRows = [];
let chartInstances = {};
let customLayers = [];
const CUSTOM_ALLOWED = ['mlp', 'deepmlp', 'mlp_bn'];
const ML_MODEL_MAP = {
  tree: { cls: 'DecisionTreeClassifier', reg: 'DecisionTreeRegression' },
  rf: { cls: 'RandomForestClassifier', reg: 'RandomForestRegression' },
  knn: { cls: 'KNN', reg: 'KNN' },
  svm: { cls: 'SVM', reg: 'SVM' },
  nb: { cls: 'NaiveBayes', reg: null }, // NB ÁÑ°ÂõûÊ≠∏
};
const AUTO_MODEL_CANDIDATES = {
  classification: ['mlp', 'deepmlp', 'logistic'],
  regression: ['linear', 'poly', 'mlp']
};

/* ========= Â∞èÂ∑•ÂÖ∑ ========= */
const isNumeric = v => !(v === null || v === undefined || v === '') && !isNaN(parseFloat(v)) && isFinite(v);
const unique = arr => Array.from(new Set(arr));
function toCSV(rows) { if (!rows.length) return ''; const header = Object.keys(rows[0]); const out = [header.join(',')]; for (const r of rows) out.push(header.map(k => r[k]).join(',')); return out.join('\n'); }
function downloadBlob(filename, content, mime = 'text/plain') { const blob = new Blob([content], { type: mime }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href); }
function renderTable(elId, rows) { const el = document.getElementById(elId); if (!rows.length) { el.innerHTML = '<div class="muted">ÁÑ°Ë≥áÊñô</div>'; return; } const cols = Object.keys(rows[0]); const head = '<tr>' + cols.map(c => `<th>${c}</th>`).join('') + '</tr>'; const body = rows.map(r => '<tr>' + cols.map(c => `<td>${r[c]}</td>`).join('') + '</tr>').join(''); el.innerHTML = `<table><thead>${head}</thead><tbody>${body}</tbody></table>`; }
function safeStringify(obj) {
  const seen = new WeakSet();
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === 'function') return undefined; // ÁßªÈô§ÂáΩÂºè
    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) return undefined;           // ÁßªÈô§Âæ™Áí∞
      seen.add(value);
    }
    return value;
  }, 2);
}
function calcClassificationMetrics(yTrue, yPred, labels) {
  const results = {};
  labels.forEach(label => {
    const tp = yTrue.filter((y, i) => y === label && yPred[i] === label).length;
    const fp = yTrue.filter((y, i) => y !== label && yPred[i] === label).length;
    const fn = yTrue.filter((y, i) => y === label && yPred[i] !== label).length;
    const precision = tp / (tp + fp || 1);
    const recall = tp / (tp + fn || 1);
    const f1 = 2 * (precision * recall) / ((precision + recall) || 1);
    results[label] = { precision, recall, f1 };
  });
  const accuracy = yTrue.filter((y, i) => y === yPred[i]).length / yTrue.length;
  return { accuracy, perClass: results };
}

function calcROC(yTrue, yScores) {
  const thresholds = [...new Set(yScores)].sort((a, b) => b - a);
  const tpr = [], fpr = [];
  thresholds.forEach(th => {
    const tp = yTrue.filter((y, i) => y === 1 && yScores[i] >= th).length;
    const fp = yTrue.filter((y, i) => y === 0 && yScores[i] >= th).length;
    const fn = yTrue.filter((y, i) => y === 1 && yScores[i] < th).length;
    const tn = yTrue.filter((y, i) => y === 0 && yScores[i] < th).length;
    tpr.push(tp / (tp + fn || 1));
    fpr.push(fp / (fp + tn || 1));
  });
  const auc = tpr.reduce((sum, t, i) => sum + (i > 0 ? (t + tpr[i - 1]) * (fpr[i] - fpr[i - 1]) / 2 : 0), 0);
  return { fpr, tpr, auc };
}
function renderConfusionMatrix(canvasId, cm, labels) {

  if (chartInstances[canvasId]) {
    chartInstances[canvasId].destroy();
  }
  const ctx = document.getElementById(canvasId).getContext('2d');

  const data = {
    labels: labels.map(l => `Pred: ${l}`),
    datasets: labels.map((rowLabel, rowIndex) => ({
      label: `True: ${rowLabel}`,
      data: cm[rowIndex],
      backgroundColor: cm[rowIndex].map(v => {
        const maxVal = Math.max(...cm.flat());
        const intensity = v === 0 ? 0 : v / maxVal;
        const r = Math.floor(255 * intensity);         // 0 ‚Üí 255
        const g = Math.floor(255 * intensity);         // 0 ‚Üí 255
        const b = Math.floor(255 * (1 - intensity));   // 255 ‚Üí 0
        return `rgb(${r},${g},${b})`; // Ê∑±Ëóç ‚Üí ÈªÉ
      })
    }))
  };

  chartInstances[canvasId] = new Chart(ctx, {
    type: 'bar',
    data: data,
    options: {
      responsive: true,
      plugins: {
        legend: { position: 'top' },
        title: {
          display: true,
          text: 'Confusion Matrix'
        },
        tooltip: {
          callbacks: {
            label: function (context) {
              const trueLabel = context.dataset.label.replace('True: ', '');
              const predLabel = context.label.replace('Pred: ', '');
              const count = context.parsed.y;
              return `True: ${trueLabel}, Pred: ${predLabel} = ${count}`;
            }
          }
        }
      },
      scales: {
        x: { stacked: true },
        y: { stacked: true, beginAtZero: true }
      }
    }
  });
}
function renderMetricsTable(elId, metrics) {

  const el = document.getElementById(elId);
  let html = `<h5>Performance Report</h5>`;
  html += `<p>Accuracy: ${(metrics.accuracy * 100).toFixed(2)}%</p>`;
  html += `<table border="1" cellpadding="5" cellspacing="0">
      <tr><th>Class</th><th>Precision</th><th>Recall</th><th>F1</th></tr>`;
  for (const cls in metrics.perClass) {
    const { precision, recall, f1 } = metrics.perClass[cls];
    html += `<tr>
        <td>${cls}</td>
        <td>${(precision * 100).toFixed(2)}%</td>
        <td>${(recall * 100).toFixed(2)}%</td>
        <td>${(f1 * 100).toFixed(2)}%</td>
      </tr>`;
  }
  html += `</table>`;
  el.innerHTML = html;
}
function renderROC(canvasId, fpr, tpr, auc) {
  // Â¶ÇÊûúËàäÂúñË°®Â≠òÂú® ‚Üí ÂÖà destroy
  if (chartInstances[canvasId]) {
    chartInstances[canvasId].destroy();
  }

  const ctx = document.getElementById(canvasId).getContext('2d');
  chartInstances[canvasId] = new Chart(ctx, {
    type: 'line',
    data: {
      labels: fpr,
      datasets: [{
        label: `ROC Curve (AUC = ${auc.toFixed(3)})`,
        data: fpr.map((x, i) => ({ x, y: tpr[i] })),
        borderColor: '#e67e22',
        fill: false
      }]
    },
    options: {
      responsive: true,
      scales: {
        x: { type: 'linear', min: 0, max: 1, title: { display: true, text: 'False Positive Rate' } },
        y: { min: 0, max: 1, title: { display: true, text: 'True Positive Rate' } }
      }
    }
  });
}
function getModelSummaryText(model) {
  const lines = [];
  lines.push(`üì¶ Model: ${model.name || 'Unnamed Model'}`);
  lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
  lines.push(` No  | Layer Name         | Type       | Output Shape     | Params`);
  lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

  model.layers.forEach((layer, i) => {
    const name = layer?.name || `layer_${i}`;
    const className = typeof layer.getClassName === 'function'
      ? layer.getClassName()
      : (layer?.className || 'Unknown');
    const outputShape = JSON.stringify(layer?.outputShape || '‚Äî');
    const paramCount = layer?.countParams?.() || 0;

    lines.push(
      `${String(i + 1).padEnd(4)}| ${name.padEnd(20)} | ${className.padEnd(10)} | ${outputShape.padEnd(16)} | ${paramCount}`
    );
  });

  lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
  lines.push(`Total params: ${model.countParams()}`);
  return lines.join('\n');
}

function addLayerFromUI() {
  const type = document.getElementById('layerTypeSelect').value;
  addLayer(type); // Âä†ÂÖ•ÊåáÂÆöÈ°ûÂûãÁöÑÂ±§
}

function logAutoInfo(text) {
  const el = document.getElementById('autoLog');
  el.textContent += text + '\n';
}

/* ========= ÂàÜÈ†Å ========= */
document.addEventListener('DOMContentLoaded', () => {
  const tabs = document.querySelectorAll('.tab');
  const views = {
    data: document.getElementById('tab-data'),
    config: document.getElementById('tab-config'),
    train: document.getElementById('tab-train'),
    predict: document.getElementById('tab-predict'),
    glossary: document.getElementById('tab-glossary')
  };
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');
      const key = tab.getAttribute('data-tab');
      Object.entries(views).forEach(([k, el]) => el.classList.toggle('hidden', k !== key));
    });
  });
});

/* ========= ÂâçËôïÁêÜ ========= */
function buildPreprocessorCustom(data, target, featureCols, colTypes, normalize = true) {
  const catMaps = {}, numStats = {};
  for (const c of featureCols.filter(c => colTypes[c] === 'numeric')) {
    const vec = data.map(r => { const v = parseFloat(r[c]); return isFinite(v) ? v : 0; });
    const mn = Math.min(...vec), mx = Math.max(...vec);
    const range = (mx - mn) || 1;
    const mean = vec.reduce((a, b) => a + b, 0) / vec.length;
    const std = Math.sqrt(vec.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / vec.length) || 1;
    numStats[c] = { min: mn, max: mx, range, mean, std };
  }
  for (const c of featureCols.filter(c => colTypes[c] === 'category')) {
    const cats = unique(data.map(r => r[c] ?? ''));
    catMaps[c] = {}; cats.forEach((v, i) => catMaps[c][v] = i);
  }
  return { featureCols, colTypes, catMaps, numStats, normalize };
}
function transformFeatures(data, metaPrep) {
  const { featureCols, colTypes, catMaps, numStats, normalize } = metaPrep;
  const out = [];
  for (const r of data) {
    let row = [];
    for (const c of featureCols) {
      if (colTypes[c] === 'numeric') {
        let v = parseFloat(r[c]); if (!isFinite(v)) v = 0;
        if (normalize) { const { min, range } = numStats[c]; v = (v - min) / range; }
        else { const { mean, std } = numStats[c]; v = (v - mean) / std; }
        row.push(v);
      } else {
        const map = catMaps[c], dim = Object.keys(map).length;
        const vec = new Array(dim).fill(0), idx = map[r[c]];
        if (idx !== undefined) vec[idx] = 1;
        row = row.concat(vec);
      }
    }
    out.push(row);
  }
  return out;
}
function inferTaskFromY(yRaw) {
  const numy = yRaw.filter(isNumeric).length, uniq = unique(yRaw);
  if (numy < yRaw.length || uniq.length <= Math.min(20, yRaw.length / 5)) return 'classification';
  return 'regression';
}
function buildLabelMapping(yRaw) {
  const isAllNum = yRaw.every(isNumeric); const uniq = unique(yRaw);
  if (!isAllNum || uniq.length <= Math.min(20, yRaw.length / 5)) { const map = {}; uniq.forEach((v, i) => map[v] = i); return { task: 'classification', map, classes: uniq }; }
  return { task: 'regression' };
}
function prepareXY(data, target, normalize) {
  const yRaw = data.map(r => r[target]);
  // ËÆÄÊ¨Ñ‰ΩçË®≠ÂÆöÔºàÂéüÊ®£Ôºâ
  const rows = [...document.querySelectorAll('#varTable tbody tr')];
  const featureCols = [], colTypes = {};
  rows.forEach(row => {
    const colName = row.cells[0].textContent;
    const typeSel = row.cells[1].querySelector('select').value;
    const useFeat = row.cells[2].querySelector('input').checked;
    if (colName !== target && useFeat) {
      featureCols.push(colName);
      if (typeSel === 'auto') {
        const sample = data.map(r => r[colName]).slice(0, 200);
        const numCount = sample.filter(isNumeric).length;
        colTypes[colName] = (numCount === sample.length) ? 'numeric' : 'category';
      } else colTypes[colName] = typeSel;
    }
  });

  const prep = buildPreprocessorCustom(data, target, featureCols, colTypes, normalize);
  const X = transformFeatures(data, prep);

  let y, labelInfo = null;
  let task = document.getElementById('taskSelect').value;
  if (task === 'auto') task = inferTaskFromY(yRaw);

  if (task === 'classification') {
    labelInfo = buildLabelMapping(yRaw);
    y = yRaw.map(v => labelInfo.map[v]);
    prep.labelInfo = labelInfo;

  } else {
    // ÂõûÊ≠∏
    y = yRaw.map(v => parseFloat(v));

    const normTarget = !!document.getElementById('normalizeTarget')?.checked;

    // ÂÖàÊ∏ÖÁ©∫ÔºåÈÅøÂÖçÊÆòÁïô
    prep.normalizeTarget = false;
    delete prep.yMean;
    delete prep.yStd;

    if (normTarget) {
      const yTensor = tf.tensor1d(y);
      const { mean, variance } = tf.moments(yTensor);
      const yMean = mean.arraySync();
      const yStd  = Math.sqrt(variance.arraySync()) || 1;

      if (Number.isFinite(yStd) && yStd > 0) {
        y = y.map(v => (v - yMean) / yStd);
        prep.normalizeTarget = true;
        prep.yMean = yMean;
        prep.yStd  = yStd;
      }
      yTensor.dispose(); mean.dispose(); variance.dispose();
    }
  }

  return { X, y, meta: { ...prep, targetCol: target, task } };
}

/* ========= TF.js Âª∫Ê®° ========= */
/* =========================
 * Learning Rate Schedules
 * ========================= */

/** Áî¢Áîü‰∏ÄÂÄãÂú®ÊØèÂÄã epoch ÈñãÈ†≠Ë™øÊï¥Â≠∏ÁøíÁéáÁöÑÂõûÂëº */
function getLRSchedulerCallback(model, baseLR = 1e-3, scheduleType = 'constant', totalEpochs = 50, options = {}) {
  const stepSize = options.stepSize ?? 10;
  const gamma = options.gamma ?? 0.5;
  const expK = options.expK ?? 0.05;
  let currentLR = baseLR; // Áõ¥Êé•Â≠òÂú®ÈñâÂåÖ

  function lrOf(epoch) {
    switch (scheduleType) {
      case 'step_decay': return baseLR * Math.pow(gamma, Math.floor(epoch / stepSize));
      case 'exp_decay': return baseLR * Math.exp(-expK * epoch);
      case 'cosine_decay': return baseLR * 0.5 * (1 + Math.cos(Math.PI * epoch / Math.max(1, totalEpochs)));
      default: return baseLR;
    }
  }

  return {
    onEpochBegin: async (epoch) => {
      currentLR = lrOf(epoch);
      if (model?.optimizer) {
        if (typeof model.optimizer.learningRate === 'number') {
          model.optimizer.learningRate = currentLR;
        } else if (model.optimizer.learningRate?.assign) {
          model.optimizer.learningRate.assign(currentLR);
        } else if (model.optimizer.setLearningRate) {
          model.optimizer.setLearningRate(currentLR);
        }
      }
    },
    getCurrentLR: () => currentLR
  };
}

/** Âè™Ë≤†Ë≤¨ÂõûÂÇ≥‰∏ÄÂÄãÂü∫Á§é optimizerÔºà‰∏çÂÖßÂª∫ scheduleÔºâ */
function getOptimizer(baseLR = 1e-3) {
  return tf.train.adam(baseLR);
}

/* =========================
 * Model Factory
 * ========================= */
document.getElementById("modelSelect").addEventListener("change", function () {
  const selected = this.value;
  const toggle = document.getElementById("customModelToggle");

  // Á¶ÅÁî®ÈÄ≤ÈöéÊ®°ÂºèÂàáÊèõÈñãÈóú
  if (!CUSTOM_ALLOWED.includes(selected)) {
    toggle.checked = false;
    toggle.disabled = true;
    document.getElementById("customLayersContainer").style.display = "none";
  } else {
    toggle.disabled = false;
  }
});

document.getElementById("customModelToggle").addEventListener("change", function () {
  const enabled = this.checked;
  document.getElementById("customLayersContainer").style.display = enabled ? "block" : "none";
  document.getElementById("modelSelect").disabled = enabled;
  if (!enabled) customLayers = [];
});

// üß± Êñ∞Â¢û‰∏ÄÂ±§
function addLayer(type = 'dense', config = {}) {
  const idx = customLayers.length;
  const container = document.createElement('div');
  container.classList.add('layer-item');
  container.id = `layer-${idx}`;

  let html = `<strong>Layer ${idx + 1}: ${type}</strong><br/>`;

  if (type === 'dense') {
    html += `
        <label>Units: <input type="number" value="${config.units || 64}" onchange="updateLayer(${idx}, 'units', this.value)"></label>
        <label>Activation:
          <select onchange="updateLayer(${idx}, 'activation', this.value)">
            <option value="relu">relu</option>
            <option value="tanh">tanh</option>
            <option value="sigmoid">sigmoid</option>
            <option value="linear">linear</option>
          </select>
        </label>
      `;
    customLayers.push({ type: 'dense', units: config.units || 64, activation: config.activation || 'relu' });
  }

  else if (type === 'dropout') {
    html += `
        <label>Rate: <input type="number" step="0.05" value="${config.rate || 0.3}" onchange="updateLayer(${idx}, 'rate', this.value)"></label>
      `;
    customLayers.push({ type: 'dropout', rate: config.rate || 0.3 });
  }

  else if (type === 'batchnorm') {
    html += `<span>Batch NormalizationÔºàÁÑ°ÂèÉÊï∏Ôºâ</span>`;
    customLayers.push({ type: 'batchnorm' });
  }

  else if (type === 'activation') {
    html += `
        <label>Function:
          <select onchange="updateLayer(${idx}, 'activation', this.value)">
            <option value="relu">relu</option>
            <option value="tanh">tanh</option>
            <option value="sigmoid">sigmoid</option>
            <option value="softmax">softmax</option>
          </select>
        </label>
      `;
    customLayers.push({ type: 'activation', activation: config.activation || 'relu' });
  }

  else if (type === 'flatten') {
    html += `<span>FlattenÔºàÁÑ°ÂèÉÊï∏Ôºâ</span>`;
    customLayers.push({ type: 'flatten' });
  }

  html += `<button onclick="removeLayer(${idx})">‚ùå</button>`;

  container.innerHTML = html;
  document.getElementById("layerList").appendChild(container);
}

function updateLayer(index, key, value) {
  if (key === 'units') customLayers[index].units = parseInt(value);
  else if (key === 'dropout') customLayers[index].dropout = parseFloat(value);
  else customLayers[index][key] = value;
}

function removeLayer(index) {
  customLayers.splice(index, 1);
  document.getElementById(`layer-${index}`).remove();
}

function makeModel(
  inputDim,
  task,
  modelType,
  nClasses = 2,
  lr = 0.001,
  scheduleType = 'constant',
  epochs = 50,
  // ÂèØÈÅ∏Ê≠£ÂâáÂåñËàáÁµêÊßãÂèÉÊï∏
  opts = {
    l2: 0,                // L2 Ê≠£ÂâáÂåñ‰øÇÊï∏Ôºà0 Ë°®Á§∫‰∏çÂïüÁî®Ôºâ
    dropout: 0.2,         // È†êË®≠ dropout
    wideUnitsFactor: 2,   // wide_deep ÂØ¨Â∫¶ÂÄçÁéá
    tabnetGateUnits: null // È†êÁïôÔºötabnet-like ÂèØË™øÂñÆÂÖÉ
  }
) {
  const isCls = task === 'classification';
  const binary = isCls && nClasses === 2;

  // build optimizerÔºàÂ≠∏ÁøíÁéáÁï∂‰∏ãÂÄºÔºõÂãïÊÖãË™øÊï¥Èù† callbackÔºâ
  const opt = getOptimizer(lr);

  // ÂÖ±Áî®Â∑•ÂÖ∑
  const reg = opts.l2 > 0 ? tf.regularizers.l2({ l2: opts.l2 }) : undefined;
  const model = tf.sequential();
  // output & compile
  const compileForTask = () => {
    if (isCls) {
      model.compile({
        optimizer: opt,
        loss: binary ? 'binaryCrossentropy' : 'sparseCategoricalCrossentropy',
        metrics: ['accuracy']
      });
    } else {
      model.compile({ optimizer: opt, loss: 'meanSquaredError' });
    }
  };
  // ‚úÖ Â¶ÇÊûúÂïüÁî®ÈÄ≤ÈöéÊ®°Âºè
  const useCustom = document.getElementById("customModelToggle")?.checked;
  if (useCustom && customLayers.length > 0) {
    customLayers.forEach((layer, index) => {
      const isFirst = index === 0;

      switch (layer.type) {
        case 'dense':
          model.add(tf.layers.dense({
            inputShape: isFirst ? [inputDim] : undefined,
            units: layer.units,
            activation: layer.activation || 'relu',
            kernelRegularizer: reg
          }));
          break;

        case 'dropout':
          model.add(tf.layers.dropout({
            rate: layer.rate ?? 0.3
          }));
          break;

        case 'batchnorm':
          model.add(tf.layers.batchNormalization());
          break;

        case 'activation':
          model.add(tf.layers.activation({
            activation: layer.activation || 'relu'
          }));
          break;

        case 'flatten':
          model.add(tf.layers.flatten());
          break;

        case 'reshape':
          model.add(tf.layers.reshape({
            targetShape: layer.targetShape || [inputDim] // ‰Ω†ÂèØËÆì‰ΩøÁî®ËÄÖËº∏ÂÖ• [h,w] ÈÄôÈ°û
          }));
          break;

        // ÂèØ‰ª•‰æùÈúÄÊ±ÇÊì¥ÂÖÖ CNN„ÄÅLSTM Á≠â
        default:
          console.warn(`Êú™Áü•Â±§È°ûÂûãÔºö${layer.type}`);
      }
    });
    // Ëº∏Âá∫Â±§
    model.add(tf.layers.dense({ units: isCls ? (binary ? 1 : nClasses) : 1, activation: isCls ? (binary ? 'sigmoid' : 'softmax') : 'linear' }));
    model.compile({
      optimizer: opt,
      loss: isCls ? (binary ? 'binaryCrossentropy' : 'sparseCategoricalCrossentropy') : 'meanSquaredError',
      metrics: isCls ? ['accuracy'] : [],
    });
    return model;
  }
  // ===== Âü∫Á§éÊ®°ÂûãÈ°ûÂûã =====
  // ===== Á∑öÊÄß / ÈÇèËºØÊñØ / Â§öÈ†ÖÂºè =====
  if (modelType === 'linear' && !isCls) {
    model.add(tf.layers.dense({ inputShape: [inputDim], units: 1, activation: 'linear', kernelRegularizer: reg }));
    compileForTask();
    return model;
  }

  if (modelType === 'logistic' && isCls) {
    model.add(tf.layers.dense({
      inputShape: [inputDim],
      units: binary ? 1 : nClasses,
      activation: binary ? 'sigmoid' : 'softmax',
      kernelRegularizer: reg
    }));
    compileForTask();
    return model;
  }

  if (modelType === 'poly' && !isCls) {
    model.add(tf.layers.dense({ inputShape: [inputDim], units: Math.max(4, inputDim * 2), activation: 'relu', kernelRegularizer: reg }));
    if (opts.dropout > 0) model.add(tf.layers.dropout({ rate: opts.dropout / 2 }));
    model.add(tf.layers.dense({ units: 1, activation: 'linear', kernelRegularizer: reg }));
    compileForTask();
    return model;
  }

  // ===== ÈÄöÁî®Á©çÊú® =====
  const addBlock = (units, { useBN = false, dropout = 0 } = {}) => {
    model.add(tf.layers.dense({ units, activation: 'relu', kernelRegularizer: reg }));
    if (useBN) model.add(tf.layers.batchNormalization());
    if (dropout > 0) model.add(tf.layers.dropout({ rate: dropout }));
  };

  // ===== LSTM ÂÆ∂Êóè =====
  if (['rnn', 'lstm'].includes(modelType)) {
    // üìå RNN/LSTM ÈúÄË¶Å 3D Ëº∏ÂÖ•
    model.add(tf.layers.reshape({ targetShape: [inputDim, 1], inputShape: [inputDim] }));

    if (modelType === 'rnn') {
      model.add(tf.layers.simpleRNN({ units: 32, activation: 'relu', returnSequences: false }));
    } else if (modelType === 'lstm') {
      model.add(tf.layers.lstm({ units: 32, activation: 'tanh', returnSequences: false }));
    }

    model.add(tf.layers.dense({ units: 16, activation: 'relu' }));
  }

  // ===== MLP ÂÆ∂Êóè =====
  if (modelType === 'mlp') {
    model.add(tf.layers.dense({ inputShape: [inputDim], units: 64, activation: 'relu', kernelRegularizer: reg }));
    if (opts.dropout > 0) model.add(tf.layers.dropout({ rate: opts.dropout }));
    addBlock(32, { useBN: false, dropout: 0 });
  }

  if (modelType === 'mlp_bn') {
    model.add(tf.layers.dense({ inputShape: [inputDim], units: 64, activation: 'relu', kernelRegularizer: reg }));
    model.add(tf.layers.batchNormalization());
    addBlock(32, { useBN: true, dropout: Math.min(0.1, opts.dropout) });
  }

  if (modelType === 'deepmlp') {
    model.add(tf.layers.dense({ inputShape: [inputDim], units: 128, activation: 'relu', kernelRegularizer: reg }));
    if (opts.dropout > 0) model.add(tf.layers.dropout({ rate: Math.max(opts.dropout, 0.3) }));
    addBlock(64, { useBN: true, dropout: 0.2 });
    addBlock(32, { useBN: false, dropout: 0 });
  }

  // ===== Wide & DeepÔºà‰ª•‰∏≤Êé•Ëøë‰ººÔºâ=====
  if (modelType === 'wide_deep') {
    const wideUnits = Math.min(256, Math.max(32, Math.floor(inputDim * (opts.wideUnitsFactor ?? 2))));
    // wideÔºöÁ∑öÊÄßÊäïÂΩ±
    model.add(tf.layers.dense({ inputShape: [inputDim], units: wideUnits, activation: 'linear', kernelRegularizer: reg }));
    // deepÔºöÈùûÁ∑öÊÄß
    addBlock(128, { useBN: true, dropout: 0.1 });
    addBlock(64, { useBN: false, dropout: 0.1 });
  }

  // ===== TabNet-likeÔºàÁ∞°ÂåñÔºâ=====
  if (modelType === 'tabnet') {
    model.add(tf.layers.dense({ inputShape: [inputDim], units: inputDim, activation: 'linear', kernelRegularizer: reg }));
    addBlock(64, { useBN: true, dropout: 0.1 });
    addBlock(32, { useBN: false, dropout: 0.1 });
  }

  // Ëã•ÂâçÈù¢Ê≤íÂëΩ‰∏≠Ôºåfallback Êàê‰∏ÄÂÄã MLP
  if (model.layers.length === 0) {
    model.add(tf.layers.dense({ inputShape: [inputDim], units: 64, activation: 'relu', kernelRegularizer: reg }));
    if (opts.dropout > 0) model.add(tf.layers.dropout({ rate: opts.dropout }));
  }

  // Ëº∏Âá∫Â±§
  if (isCls) {
    model.add(tf.layers.dense({
      units: binary ? 1 : nClasses,
      activation: binary ? 'sigmoid' : 'softmax',
      kernelRegularizer: reg
    }));
  } else {
    model.add(tf.layers.dense({ units: 1, activation: 'linear', kernelRegularizer: reg }));
  }

  compileForTask();
  return model;
}

/* ========= ÂúñË°® ========= */
let chartsInit = false;
const charts = { loss: null, acc: null };
function ensureCharts() {
  if (chartsInit) return;
  chartsInit = true;
  charts.loss = new Chart(document.getElementById('lossChart'), {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label: 'Train Loss', data: [], borderColor: '#27ae60', backgroundColor: 'rgba(39,174,96,0.1)' },
        { label: 'Val Loss', data: [], borderColor: '#e74c3c', backgroundColor: 'rgba(231,76,60,0.1)' }
      ]
    },
    options: { responsive: true, animation: false }
  });
  charts.acc = new Chart(document.getElementById('accChart'), { type: 'line', data: { labels: [], datasets: [{ label: 'Val Accuracy', data: [], borderColor: '#3498db', backgroundColor: 'rgba(52,152,219,.1)' }] }, options: { responsive: true, animation: false } });

  charts.lr = new Chart(document.getElementById('lrChart'), {
    type: 'line',
    data: {
      labels: [],
      datasets: [{ label: 'Learning Rate', data: [], borderColor: '#8e44ad', backgroundColor: 'rgba(142,68,173,0.1)' }]
    },
    options: { responsive: true, animation: false }
  });

}
function resetCharts(showAcc) {
  ensureCharts();
  charts.loss.data.labels = [];
  charts.loss.data.datasets[0].data = [];
  charts.loss.data.datasets[1].data = []; // ‚Üê Âä†‰∏äÈÄôË°å
  charts.loss.update();

  charts.acc.data.labels = [];
  charts.acc.data.datasets[0].data = [];
  charts.acc.update();

  // lr
  charts.lr.data.labels = [];
  charts.lr.data.datasets[0].data = [];
  charts.lr.update();


  document.getElementById('accChart').style.display = showAcc ? 'block' : 'none';
}

/* ========= DOM Á∂ÅÂÆö ========= */
document.addEventListener('DOMContentLoaded', () => {

  /* --- 1) ËºâÂÖ•Ë≥áÊñôÈ†Å --- */
  const trainCsv = document.getElementById('trainCsv');
  const trainPreview = document.getElementById('trainPreview');
  const targetSelect = document.getElementById('targetSelect');
  const varTbody = document.querySelector('#varTable tbody');

  trainCsv.addEventListener('change', (e) => {
    const file = e.target.files?.[0]; if (!file) return;
    Papa.parse(file, {
      header: true, skipEmptyLines: true, complete: (res) => {
        rawData = res.data;
        columns = res.meta.fields || Object.keys(rawData[0] || {});
        // ÁõÆÊ®ôÊ¨Ñ‰ΩçÊ∏ÖÂñÆ
        targetSelect.innerHTML = '';
        columns.forEach(c => { const opt = document.createElement('option'); opt.value = c; opt.textContent = c; targetSelect.appendChild(opt); });
        // ËÆäÊï∏Ë®≠ÂÆöË°®
        varTbody.innerHTML = '';
        columns.forEach(c => {
          const tr = document.createElement('tr');
          const nameTd = document.createElement('td'); nameTd.textContent = c;
          const typeTd = document.createElement('td'); const sel = document.createElement('select'); sel.innerHTML = '<option value="auto">Ëá™ÂãïÂà§Êñ∑</option><option value="numeric">Êï∏ÂÄº</option><option value="category">È°ûÂà•</option>'; typeTd.appendChild(sel);
          const featTd = document.createElement('td'); const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = true; featTd.appendChild(chk);
          tr.appendChild(nameTd); tr.appendChild(typeTd); tr.appendChild(featTd);
          varTbody.appendChild(tr);
        });
        trainPreview.textContent = `Â∑≤ËºâÂÖ•Ôºö${file.name}Ôºà${rawData.length} Ë°å √ó ${columns.length} Ê¨ÑÔºâ`;
        document.getElementById('downloadMetaBtn').disabled = false; // ‰πãÂæåÂèØÊääÁï∂ÂâçË®≠ÂÆöÂ≠ò metadata.json
      }
    });
  });

  /* --- 2) Ê®°ÂûãË®≠ÂÆöÈ†ÅÔºöËºâÂÖ•Êó¢Êúâ TF.js Ê®°Âûã --- */
  const loadModelBtn = document.getElementById('loadModelBtn');
  const loadStatus = document.getElementById('loadStatus');
  const resetModelBtn = document.getElementById('resetModelBtn');
  resetModelBtn.addEventListener('click', () => {
    try {
      if (tfModel?.dispose) tfModel.dispose();
    } catch (_) { }
    tfModel = null;
    traditionalModel = null;
    meta = null; // Ê∏ÖÊéâÂâçËôïÁêÜÔºåÈÅøÂÖçËàäË®≠ÂÆöË™§Áî®

    // ÂÅúÁî®ËàáÊ∏ÖÁêÜ UI ÁãÄÊÖã
    document.getElementById('predictBtn').disabled = true;
    document.getElementById('downloadModelBtn').disabled = true;
    document.getElementById('downloadMLModelBtn').disabled = true;
    document.getElementById('downloadMetaBtn').disabled = true;

    // Ë®äÊÅØÊèêÁ§∫ÔºàÊ®°ÂûãË®≠ÂÆöÂàÜÈ†ÅÔºâ
    const loadStatus = document.getElementById('loadStatus');
    if (loadStatus) loadStatus.textContent = 'üßπ Â∑≤Ê∏ÖÁ©∫ÁõÆÂâçÊ®°ÂûãËàáË®≠ÂÆöÔºåË´ãÈáçÊñ∞Ë®ìÁ∑¥ÊàñËºâÂÖ• TF.js Ê®°Âûã + metadata.json';

    // Ë®ìÁ∑¥È†ÅÁãÄÊÖãÂàó
    const statusEl = document.getElementById('status');
    if (statusEl) statusEl.textContent = 'üßπ Â∑≤Ê∏ÖÁ©∫Ê®°Âûã';
  });

  loadModelBtn.addEventListener('click', async () => {
    loadStatus.textContent = 'ËÆÄÂèñ‰∏≠‚Ä¶';
    try {
      const jsonFile = document.getElementById('modelJson').files[0];
      const binFile = document.getElementById('modelBin').files[0];
      const metaFile = document.getElementById('metaJson').files[0];
      if (!jsonFile) throw new Error('Ë´ãÈÅ∏Êìá model.json');
      if (!binFile) throw new Error('Ë´ãÈÅ∏Êìá .bin Ê¨äÈáçÊ™î');
      if (!metaFile) throw new Error('Ë´ãÈÅ∏Êìá metadata.json');

      if (!jsonFile.name.toLowerCase().endsWith('.json')) throw new Error('model.json Ê™îÂêç‰∏çÊ≠£Á¢∫');
      if (!binFile.name.toLowerCase().endsWith('.bin')) throw new Error('Ê¨äÈáçÊ™îÈúÄÁÇ∫ .bin');
      if (!metaFile.name.toLowerCase().endsWith('.json')) throw new Error('metadata.json Ê™îÂêç‰∏çÊ≠£Á¢∫');

      if (tfModel?.dispose) tfModel.dispose();
      tfModel = await tf.loadLayersModel(tf.io.browserFiles([jsonFile, binFile]));

      const metaText = await metaFile.text();
      const cleaned = metaText.replace(/[\u0000-\u001F\u007F]/g, '');
      const parsed = JSON.parse(cleaned);
      if (!parsed || !parsed.featureCols || !parsed.colTypes) throw new Error('metadata.json ÁµêÊßã‰∏çÂÆåÊï¥');
      meta = parsed;
      if (meta.normalizeTarget == null) meta.normalizeTarget = false;


      loadStatus.textContent = '‚úÖ Ê®°ÂûãËàáË®≠ÂÆöËºâÂÖ•ÂÆåÊàê';
      document.getElementById('predictBtn').disabled = false;
    } catch (err) {
      console.error(err);
      loadStatus.textContent = '‚ùå ËºâÂÖ•Â§±ÊïóÔºö' + err.message;
    }
  });

  /* --- 3) Ë®ìÁ∑¥È†Å --- */
  const trainBtn = document.getElementById('trainBtn');
  const statusEl = document.getElementById('status');

  document.getElementById('modelSelect').addEventListener('change', (e) => {
    const val = e.target.value;
    const treeModels = ['tree', 'rf', 'extra_tree']; // ÂèØ‰ª•Êì¥ÂÖÖ
    if (treeModels.includes(val)) {
      document.getElementById('treeParams').style.display = 'block';
    } else {
      document.getElementById('treeParams').style.display = 'none';
    }
  });

  trainBtn.addEventListener('click', async () => {
    try {
      if (!rawData.length) { alert('Ë´ãÂÖàÂà∞„ÄåËºâÂÖ•Ë≥áÊñô„ÄçÈ†Å‰∏äÂÇ≥ CSV'); return; }
      const target = document.getElementById('targetSelect').value;
      if (!target) { alert('Ë´ãÈÅ∏ÊìáÁõÆÊ®ôÊ¨Ñ‰Ωç'); return; }

      const modelSel = document.getElementById('modelSelect').value;
      const epochs = parseInt(document.getElementById('epochs').value, 10);
      const batchSize = parseInt(document.getElementById('batchSize').value, 10);
      const lr = parseFloat(document.getElementById('lr').value);
      const scheduleType = (document.getElementById('lrSchedule')?.value) || 'constant';
      const ratio = Math.max(0.5, Math.min(0.95, parseFloat(document.getElementById('trainRatio').value) || 0.8));
      const normalize = document.getElementById('normalize').checked;

      statusEl.textContent = 'Ë≥áÊñôÂâçËôïÁêÜ‰∏≠‚Ä¶';
      const { X, y, meta: prep } = prepareXY(rawData, target, normalize);
      meta = { ...prep, modelType: modelSel }; // ‰øùÂ≠òË®≠ÂÆöÂà∞ÂÖ®Âüü
      // Âàá train/test
      const n = X.length, idx = [...Array(n).keys()];
      for (let i = n - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[idx[i], idx[j]] = [idx[j], idx[i]]; }
      const cut = Math.floor(n * ratio), tr = idx.slice(0, cut), te = idx.slice(cut);
      const Xtr = tr.map(i => X[i]), ytr = tr.map(i => y[i]), Xte = te.map(i => X[i]), yte = te.map(i => y[i]);

      const traditionalList = Object.keys(ML_MODEL_MAP);
      const isTraditional = traditionalList.includes(modelSel);

      // ÂúñË°® reset
      resetCharts(!isTraditional && meta.task === 'classification');
      document.getElementById('metricsBox').style.display = 'block';
      document.getElementById('bestMetric').textContent = '‚Äî';
      document.getElementById('finalMetric').textContent = '‚Äî';

      // Auto Ê±∫Á≠ñ
      if (modelSel === 'auto') {
        const candidates = AUTO_MODEL_CANDIDATES[meta.task];
        let bestScore = meta.task === 'classification' ? 0 : Infinity;
        let bestModel = null;
        let bestModelType = null;

        for (const modelType of candidates) {
          statusEl.textContent = `AutoML ÂòóË©¶Ê®°ÂûãÔºö${modelType}`;

          // 1) Âª∫Ê®°ÂûãÊôÇÂÇ≥ÂÖ• modelType
          const model = makeModel(
            Xtr[0].length,
            meta.task,
            modelType,                                  // ‚Üê ÈÄôË£°
            (meta.labelInfo?.classes.length || 2),
            lr,
            scheduleType,
            epochs
          );

          const isSequenceModel = ['rnn', 'lstm'].includes(modelType);

          const xTr = isSequenceModel
            // Ê≥®ÊÑèÔºöÈÄôË£°Ë¶ÅÂëºÂè´Â∞èÂØ´ÁöÑ Xtr
            ? tf.tensor2d(Xtr).reshape([Xtr.length, Xtr[0].length, 1])
            : tf.tensor2d(Xtr);
          const yTrT = tf.tensor1d(ytr, 'float32');
          const xTe = isSequenceModel
            ? tf.tensor2d(Xte).reshape([Xte.length, Xtr[0].length, 1])
            : tf.tensor2d(Xte);
          const yTeT = tf.tensor1d(yte, 'float32');





          let currentBest = meta.task === 'classification' ? 0 : Infinity;
          let history;

          try {
            history = await model.fit(xTr, yTrT, {
              epochs,
              batchSize,
              shuffle: true,
              validationData: [xTe, yTeT],
              verbose: 0,
              callbacks: {
                onEpochEnd: (epoch, logs) => {
                  const metric = meta.task === 'classification'
                    ? logs.val_accuracy ?? logs.val_acc ?? 0
                    : logs.val_loss ?? Infinity;

                  if (meta.task === 'classification') {
                    if (metric > currentBest) currentBest = metric;
                  } else {
                    if (metric < currentBest) currentBest = metric;
                  }

                  statusEl.textContent = `Ë®ìÁ∑¥‰∏≠Ôºà${modelType}ÔºâÔºöEpoch ${epoch + 1}/${epochs} ‚Üí Score = ${metric.toFixed(4)}`;
                }
              }
            });
          } catch (err) {
            console.error(`‚ùå Ê®°Âûã ${modelType} Ë®ìÁ∑¥ÈåØË™§Ôºö${err.message}`);
            model.dispose();
            continue; // Ë∑≥ÈÅéÈÄôÂÄãÊ®°Âûã
          }

          // Ë®ìÁ∑¥ÂÆåÊàêÂæå ‚Üí Ê±∫ÂÆöÊòØÂê¶‰øùÁïô
          let finalMetric;
          const metricArr = meta.task === 'classification'
            ? history.history.val_accuracy ?? history.history.val_acc
            : history.history.val_loss;

          finalMetric = Array.isArray(metricArr) ? metricArr.at(-1) : NaN;

          const isBetter = meta.task === 'classification'
            ? finalMetric > bestScore
            : finalMetric < bestScore;

          const tag = meta.task === 'classification' ? 'val_accuracy' : 'val_loss';
          logAutoInfo(`AutoML Ê®°Âûã ${modelType} ‚Üí ${tag} = ${finalMetric.toFixed(4)}`);
          logAutoInfo(`Ê®°Âûã ${modelType} ‚Üí best val score = ${currentBest.toFixed(4)}`);

          if (isBetter) {
            if (bestModel) bestModel.dispose(); // ÈáãÊîæÂâç‰∏ÄÂÄãÊúÄ‰Ω≥Ê®°Âûã
            bestModel = model;
            bestModelType = modelType;
            bestScore = finalMetric;
          } else {
            model.dispose(); // ‰∏çÊòØÊúÄ‰Ω≥ ‚Üí Ê∏ÖÊéâ
          }

          xTr.dispose(); yTrT.dispose(); xTe.dispose(); yTeT.dispose();
        }

        tfModel?.dispose?.();
        tfModel = bestModel;
        meta.modelType = bestModelType;

        // È°ØÁ§∫ÊúÄ‰Ω≥Ê®°ÂûãÊëòË¶Å
        const summaryText = getModelSummaryText(tfModel);
        document.getElementById('summaryText').textContent = summaryText;
        document.getElementById('modelSummary').style.display = 'block';

        // È°ØÁ§∫ÊïàËÉΩ
        document.getElementById('bestMetric').textContent =
          meta.task === 'classification' ? `Best Val Accuracy: ${bestScore.toFixed(4)}` : `Best Val MSE: ${bestScore.toFixed(6)}`;
        document.getElementById('finalMetric').textContent = `‰ΩøÁî®Ê®°ÂûãÔºö${bestModelType}`;

        statusEl.textContent = `‚úÖ ÈÄ≤Èöé AutoML ÈÅ∏Âá∫ÊúÄ‰Ω≥Ê®°ÂûãÔºö${bestModelType}`;
        document.getElementById('downloadModelBtn').disabled = false;
        document.getElementById('downloadMetaBtn').disabled = false;
        document.getElementById('predictBtn').disabled = false;

        return;
      }
      if (isTraditional) {
        const spec = ML_MODEL_MAP[modelSel];
        const ctorName = (meta.task === 'regression') ? spec.reg : spec.cls;
        const modelParams = { task: meta.task };
        if (['tree', 'rf', 'extra_tree'].includes(modelSel)) {
          modelParams.maxDepth = parseInt(document.getElementById('maxDepth').value, 10);
          modelParams.minSamplesSplit = parseInt(document.getElementById('minSamplesSplit').value, 10);
          if (modelSel === 'rf') {
            modelParams.nEstimators = parseInt(document.getElementById('nEstimators').value, 10);
          }
        }
        if (!ctorName) throw new Error(`${modelSel} ‰∏çÊîØÊè¥ ${meta.task} ‰ªªÂãô`);
        if (!MLBundle[ctorName]) throw new Error(`MLBundle.${ctorName} ‰∏çÂ≠òÂú®`);

        traditionalModel = new MLBundle[ctorName](Xtr, ytr, modelParams);


        const pred = traditionalModel.predict(Xte);
        if (meta.task === 'classification') {
          const acc = pred.filter((p, i) => p === yte[i]).length / yte.length;
          document.getElementById('bestMetric').textContent = `Accuracy = ${acc.toFixed(4)}`;
          document.getElementById('finalMetric').textContent = `Test Accuracy = ${acc.toFixed(4)}`;

          // === Confusion Matrix ===
          const uniqueLabels = [...new Set(yte)];
          // const cm = Array(uniqueLabels.length).fill(0).map(() => Array(uniqueLabels.length).fill(0));
          const labels = [...new Set(yte)];
          const toIdx = new Map(labels.map((l, i) => [l, i]));
          const cm = Array(labels.length).fill(0).map(() => Array(labels.length).fill(0));
          yte.forEach((t, i) => {
            const ti = toIdx.get(t);
            const pi = toIdx.get(pred[i]);
            if (ti != null && pi != null) cm[ti][pi]++;
          });
          renderConfusionMatrix('confusionMatrixCanvas', cm, labels);

          if (charts.confusion) charts.confusion.destroy();
          renderConfusionMatrix('confusionMatrixCanvas', cm, uniqueLabels);

          // === Performance Report ===
          const metrics = calcClassificationMetrics(yte, pred, uniqueLabels);
          renderMetricsTable('metricsTable', metrics);

          // === ROC & AUROCÔºà‰∫åÂÖÉÂàÜÈ°ûÊâçÁï´Ôºâ===
          if (uniqueLabels.length === 2 && traditionalModel.predictProba) {
            const probs = traditionalModel.predictProba(Xte).map(v => v[1]);
            const { fpr, tpr, auc } = calcROC(yte, probs);
            renderROC('rocCanvas', fpr, tpr, auc);
          }

        } else {
          const mse = yte.reduce((s, yv, i) => s + Math.pow(yv - pred[i], 2), 0) / yte.length;
          const rmse = Math.sqrt(mse);
          document.getElementById('bestMetric').textContent = `MSE = ${mse.toFixed(6)} | RMSE = ${rmse.toFixed(6)}`;
          document.getElementById('finalMetric').textContent = `Test MSE = ${mse.toFixed(6)} | Test RMSE = ${rmse.toFixed(6)}`;
        }

        statusEl.textContent = '‚úÖ ÂÇ≥Áµ± ML Ë®ìÁ∑¥ÂÆåÊàê';
        document.getElementById('downloadModelBtn').disabled = true;
        document.getElementById('downloadMLModelBtn')?.removeAttribute('disabled');
        document.getElementById('downloadMetaBtn').disabled = false;
        document.getElementById('predictBtn').disabled = false;
        return;
      }

      // TF.js Ë®ìÁ∑¥
      traditionalModel = null;
      statusEl.textContent = 'Ë®ìÁ∑¥ TF.js Ê®°Âûã‰∏≠‚Ä¶';
      const inDim = Xtr[0].length;
      let classes = null, yTrT, yTeT;
      if (meta.task === 'classification') {
        classes = meta.labelInfo.classes;
        yTrT = tf.tensor1d(ytr.map(v => +v), 'float32');
        yTeT = tf.tensor1d(yte.map(v => +v), 'float32');
      } else {
        yTrT = tf.tensor1d(ytr, 'float32');
        yTeT = tf.tensor1d(yte, 'float32');
      }
      tfModel?.dispose?.();
      tfModel = makeModel(inDim, meta.task, modelSel, classes ? classes.length : 1, lr, scheduleType, epochs);

      const xTr = tf.tensor2d(Xtr, undefined, 'float32');
      const xTe = tf.tensor2d(Xte, undefined, 'float32');

      let best = meta.task === 'classification' ? 0 : Number.POSITIVE_INFINITY;
      // ÂÑ™ÂåñÂô®ËàáÂ≠∏ÁøíÁéáË™øÂ∫¶
      const lrCb = getLRSchedulerCallback(tfModel, lr, scheduleType, epochs, { stepSize: 10, gamma: 0.5, expK: 0.05 });

      // Ë®ìÁ∑¥Ê®°Âûã
      await tfModel.fit(xTr, yTrT, {
        epochs, batchSize, shuffle: true, validationData: [xTe, yTeT],
        callbacks: [lrCb, {
          onEpochEnd: (epoch, logs) => {
            charts.loss.data.labels.push(charts.loss.data.labels.length + 1);
            charts.loss.data.datasets[0].data.push(logs.loss);       // Train Loss
            charts.loss.data.datasets[1].data.push(logs.val_loss);   // Val Loss
            charts.loss.update();

            if (meta.task === 'classification' && (logs.val_accuracy !== undefined || logs.val_acc !== undefined)) {
              const acc = logs.val_accuracy ?? logs.val_acc ?? 0;
              charts.acc.data.labels.push(charts.acc.data.labels.length + 1);
              charts.acc.data.datasets[0].data.push(acc);
              charts.acc.update();
              if (acc > best) best = acc;
              document.getElementById('bestMetric').textContent = `Best Val Acc = ${best.toFixed(4)}`;
              document.getElementById('finalMetric').textContent = `Val Acc = ${(acc ?? 0).toFixed(4)}`;
            } else {
              const cur = logs.val_loss ?? logs.loss;
              if (cur < best) best = cur;
              document.getElementById('bestMetric').textContent = `Best Val MSE = ${best.toFixed(6)} (RMSE=${Math.sqrt(best).toFixed(6)})`;
              document.getElementById('finalMetric').textContent = `Val MSE = ${cur.toFixed(6)} (RMSE=${Math.sqrt(cur).toFixed(6)})`;
            }
            const curLR = typeof lrCb.getCurrentLR === 'function' ? lrCb.getCurrentLR() : null;

            if (curLR != null) {
              charts.lr.data.labels.push(epoch + 1);
              charts.lr.data.datasets[0].data.push(curLR);
              charts.lr.update();
            }

            statusEl.textContent = `Ë®ìÁ∑¥‰∏≠‚Ä¶ÔºàEpoch ${epoch + 1}/${epochs}Ôºâ`;
          },
          onTrainEnd: async () => {
            const yTrue = yTeT.arraySync();
            const yPredProb = tfModel.predict(xTe).arraySync();
            // ÊääÈ†êÊ∏¨ÁµêÊûúÈÉΩÊî§Âπ≥ÊàêÂñÆ‰∏ÄÊï∏ÂÄºÊàñÈ°ûÂà•Á¥¢Âºï
            const yPred = yPredProb.map(v =>
              Array.isArray(v)
                ? (v.length > 1
                  ? v.indexOf(Math.max(...v))   // multi-class
                  : v[0] > 0.5 ? 1 : 0           // binary sigmoid
                )
                : v > 0.5
                  ? 1
                  : 0
            );

            if (meta.task === 'classification') {
              // ‚îÄ‚îÄ ÂàÜÈ°ûÔºöÊ∑∑Ê∑ÜÁü©Èô£„ÄÅPerformance Report„ÄÅROC ‚îÄ‚îÄ
              const classes = [...new Set(yTrue)];
              const toIdx = new Map(classes.map((c, i) => [c, i]));
              const cm = Array(classes.length)
                .fill(0)
                .map(() => Array(classes.length).fill(0));

              yTrue.forEach((t, i) => {
                const r = toIdx.get(t), c = toIdx.get(yPred[i]);
                if (r != null && c != null) cm[r][c]++;
              });
              renderConfusionMatrix('confusionMatrixCanvas', cm, classes);

              const metrics = calcClassificationMetrics(yTrue, yPred, classes);
              renderMetricsTable('metricsTable', metrics);

              if (classes.length === 2) {
                // Âèñ class=1 ÁöÑÊ©üÁéá‰Ωú ROC
                const probs = yPredProb.map(v =>
                  Array.isArray(v) ? (v.length > 1 ? v[1] : v[0]) : v
                );
                const { fpr, tpr, auc } = calcROC(yTrue, probs);
                renderROC('rocCanvas', fpr, tpr, auc);
              }
            }
            else {
              // ‚îÄ‚îÄ ÂõûÊ≠∏ÔºöÂè™ÁÆó MSE ‚îÄ‚îÄ
              //   const preds = yPredProb.map(v =>
              //     Array.isArray(v) ? v[0] : v
              //   );
              //   const mse =
              //   yTrue.reduce((sum, t, i) => sum + Math.pow(t - preds[i], 2), 0) /
              //   yTrue.length;
              // const rmse = Math.sqrt(mse);
              // document.getElementById('finalMetric').textContent = `Final MSE = ${mse.toFixed(6)} | Final RMSE = ${rmse.toFixed(6)}`;
            }

            // summary ËàáÊåâÈàïÂïüÁî®
            const summaryText = getModelSummaryText(tfModel);
            document.getElementById('summaryText').textContent = summaryText;
            document.getElementById('modelSummary').style.display = 'block';
            statusEl.textContent = '‚úÖ Ë®ìÁ∑¥ÂÆåÊàêÔºàTF.jsÔºâ';
            document.getElementById('downloadModelBtn').disabled = false;
            document.getElementById('downloadMetaBtn').disabled = false;
            document.getElementById('downloadMLModelBtn').disabled = true;
            document.getElementById('predictBtn').disabled = false;
          }
        }]
      });
      xTr.dispose(); xTe.dispose(); yTrT.dispose(); yTeT.dispose();
    } catch (err) {
      console.error(err);
      statusEl.textContent = '‚ùå Ë®ìÁ∑¥Â§±ÊïóÔºö' + err.message;
    }
  });

  // ÂåØÂá∫
  document.getElementById('downloadModelBtn').addEventListener('click', async () => {
    if (!tfModel) { alert('ÁõÆÂâçÊ®°Âûã‰∏çÂèØ‰∏ãËºâÔºàÂÇ≥Áµ± ML ‰∏çÊîØÊè¥ÊàñÂ∞öÊú™Ë®ìÁ∑¥ TF.js Ê®°ÂûãÔºâ'); return; }
    try { await tfModel.save('downloads://tfjs_model'); } catch (e) { alert('‰∏ãËºâÂ§±ÊïóÔºö' + e.message); }
  });
  document.getElementById('downloadMetaBtn').addEventListener('click', () => {
    if (!meta) { alert('Â∞öÊú™ÊúâÂèØÂåØÂá∫ÁöÑ metadata'); return; }
    downloadBlob('metadata.json', JSON.stringify(meta, null, 2), 'application/json');
  });

  document.getElementById('downloadMLModelBtn').addEventListener('click', () => {
    if (!traditionalModel) {
      alert('ÁõÆÂâçÊ≤íÊúâÂÇ≥Áµ± ML Ê®°ÂûãÂèØÂåØÂá∫');
      return;
    }
    // ÊâìÂåÖÂøÖË¶ÅË≥áË®äÔºöÊ®°ÂûãÈ°ûÂûã/‰ªªÂãô„ÄÅÁâπÂæµË®≠ÂÆö„ÄÅÊ≠£Ë¶èÂåñ„ÄÅ‰ª•ÂèäÊ®°ÂûãÊú¨È´îÁöÑÂèØÂ∫èÂàóÂåñÁãÄÊÖã
    const pkg = {
      format: 'mlbundle-experimental-v1',
      timestamp: new Date().toISOString(),
      task: meta?.task ?? null,
      modelType: meta?.modelType ?? null,       // ‰æãÂ¶Ç 'rf', 'tree', ...
      preprocessor: meta ? {
        featureCols: meta.featureCols,
        colTypes: meta.colTypes,
        catMaps: meta.catMaps,                  // one-hot Â∞çÊáâ
        numStats: meta.numStats,                // MinMax / Z-score ÂèÉÊï∏
        normalize: meta.normalize,
        targetCol: meta.targetCol,
        labelInfo: meta.labelInfo ?? null
      } : null,
      // ÂòóË©¶Â∫èÂàóÂåñÊ®°ÂûãÔºà‰æù MLBundle ÂÖßÈÉ®ÂØ¶‰ΩúËÄåÂÆöÔºâ
      modelState: JSON.parse(safeStringify(traditionalModel))
    };

    try {
      downloadBlob('ml_model.json', JSON.stringify(pkg, null, 2), 'application/json');
    } catch (e) {
      console.error(e);
      alert('ÂåØÂá∫Â§±ÊïóÔºö' + e.message);
    }
  });


  /* --- 4) È†êÊ∏¨È†Å --- */
  const predictBtn = document.getElementById('predictBtn');
  predictBtn.addEventListener('click', () => {
    const pf = document.getElementById('predictCsv').files?.[0];
    if (!meta) { alert('Ë´ãÂÖàË®ìÁ∑¥ÊàñËºâÂÖ•Ê®°ÂûãËàá metadata'); return; }
    if (!pf) { alert('Ë´ã‰∏äÂÇ≥Ë¶ÅÈ†êÊ∏¨ÁöÑ CSV'); return; }

    const status = document.getElementById('predictStatus'); status.textContent = 'Ë≥áÊñôËôïÁêÜ‰∏≠‚Ä¶';
    Papa.parse(pf, {
      header: true, skipEmptyLines: true, complete: (res) => {
        try {
          const rows = res.data;
          const Xnew = transformFeatures(rows, meta);

          if (traditionalModel) {
            let pred = traditionalModel.predict(Xnew);

            // ‚úÖ Âè™ÊúâÁï∂„ÄåË®ìÁ∑¥ÊôÇ„ÄçÊúâÂÅöÁõÆÊ®ôÊ®ôÊ∫ñÂåñÊâçÈÇÑÂéü
            if (meta.task === 'regression' && meta.normalizeTarget &&
              Number.isFinite(meta.yMean) && Number.isFinite(meta.yStd)) {
              pred = pred.map(v => (v * meta.yStd) + meta.yMean);
            }

            if (meta.task === 'classification' && meta.labelInfo) {
              lastPredRows = rows.map((r, i) => ({
                ...r,
                È†êÊ∏¨ÂÄº: meta.labelInfo.classes[pred[i]] ?? pred[i]
              }));
            } else {
              lastPredRows = rows.map((r, i) => ({ ...r, È†êÊ∏¨ÂÄº: pred[i] }));
            }
            renderTable('predictTable', lastPredRows.slice(0, 100));
            status.textContent = '‚úÖ ÂÆåÊàêÔºàÂÇ≥Áµ± MLÔºâ';
            document.getElementById('downloadPredBtn').disabled = false;
            return;
          }

          // === TF.js Ê®°ÂûãÈ†êÊ∏¨ ===
          if (!tfModel) { alert('Ë´ãÂÖà‰ª• TF.js Ë®ìÁ∑¥ÊàñÂú®Ë®≠ÂÆöÈ†ÅËºâÂÖ• TF.js Ê®°Âûã'); return; }
          const x = tf.tensor2d(Xnew, undefined, 'float32');
          const p = tfModel.predict(x);

          if (meta.task === 'classification') {
            const probs = p.arraySync();
            const cls = meta.labelInfo?.classes || [];
            const idx = probs.map(v => {
              if (Array.isArray(v)) {
                if (v.length > 1) {
                  let mi = 0, mv = v[0];
                  for (let i = 1; i < v.length; i++) if (v[i] > mv) { mv = v[i]; mi = i; }
                  return mi;
                } else return v[0] > 0.5 ? 1 : 0;
              }
              return v > 0.5 ? 1 : 0;
            });
            lastPredRows = rows.map((r, i) => ({
              ...r,
              È†êÊ∏¨ÂÄº: (cls[idx[i]] !== undefined ? cls[idx[i]] : idx[i])
            }));
          } else {
            let vals = p.arraySync().map(v => Array.isArray(v) ? v[0] : v);

            // ‚úÖ Âè™‰æùÊìöË®ìÁ∑¥ÊôÇÁöÑ meta.normalizeTarget ‰æÜÈÇÑÂéü
            if (meta.task === 'regression' && meta.normalizeTarget &&
            Number.isFinite(meta.yMean) && Number.isFinite(meta.yStd)) {
          vals = vals.map(v => (v * meta.yStd) + meta.yMean);
        }
        
            lastPredRows = rows.map((r, i) => ({ ...r, È†êÊ∏¨ÂÄº: vals[i] }));
          }
          x.dispose(); p.dispose();
          renderTable('predictTable', lastPredRows.slice(0, 100));
          status.textContent = '‚úÖ ÂÆåÊàêÔºàTF.jsÔºâ';
          document.getElementById('downloadPredBtn').disabled = false;

        } catch (e) {
          console.error(e);
          status.textContent = '‚ùå È†êÊ∏¨Â§±ÊïóÔºö' + e.message;
        }
      }
    });
  });

  document.getElementById('downloadPredBtn').addEventListener('click', () => {
    if (!lastPredRows.length) return;
    downloadBlob('predictions.csv', toCSV(lastPredRows), 'text/csv');
  });

});
